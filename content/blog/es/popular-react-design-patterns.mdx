---
title: "Los Patrones de DiseÃ±o MÃ¡s Populares en React y CÃ³mo Aplicarlos"
summary: "React es una biblioteca increÃ­blemente flexible, pero sin una buena estructura, nuestras aplicaciones pueden volverse difÃ­ciles de mantener. En este post, exploramos los patrones de diseÃ±o mÃ¡s populares en React, desde Container/Presenter, Render Props, hasta Hooks personalizados, con ejemplos prÃ¡cticos para que puedas aplicarlos en tus proyectos y hacerlos mÃ¡s escalables y eficientes."
date: "2025-01-31"
image: "/images/blog-posts-images/popular-react-design-patterns.jpeg"
tags: [Javascript, Frontend, Clean Code, React]
---

Si alguna vez has trabajado en una aplicaciÃ³n React grande, seguro te has encontrado con un cÃ³digo desordenado y difÃ­cil de mantener. ğŸ˜µâ€ğŸ’«

La soluciÃ³n a este problema estÃ¡ en usar patrones de diseÃ±o, que nos ayudan a escribir cÃ³digo mÃ¡s limpio, reutilizable y escalable. En este post, exploraremos los patrones de diseÃ±o mÃ¡s utilizados en React con ejemplos prÃ¡cticos para que puedas implementarlos en tus proyectos.

---

### **Container/Presenter â€“ Separando LÃ³gica y UI ğŸ­**

Uno de los patrones mÃ¡s clÃ¡sicos en React es Container/Presenter, donde separamos la lÃ³gica de la presentaciÃ³n.

**ğŸ”¥ CuÃ¡ndo usarlo**
â€¢ Cuando un componente tiene demasiada lÃ³gica y re-renderiza frecuentemente.
â€¢ Para separar la capa lÃ³gica de la capa de presentaciÃ³n y mejorar la reutilizaciÃ³n.

**âŒ Antes (Componente con LÃ³gica y UI Mezcladas ğŸ˜–)**

```typescript
function UserProfile({ userId }: { userId: number }) {
	const [user, setUser] = React.useState<{ name: string; email: string } | null>(null);

	React.useEffect(() => {
		fetch(`https://api.example.com/users/${userId}`)
			.then((res) => res.json())
			.then((data) => setUser(data));
	}, [userId]);

	if (!user) return <p>Cargando...</p>;
	return (
		<h1>
			{user.name} ({user.email})
		</h1>
	);
}
```

AquÃ­, el componente maneja la lÃ³gica de datos y la UI, lo que hace difÃ­cil la reutilizaciÃ³n.

**âœ… DespuÃ©s (Aplicando Container/Presenter ğŸ¤©)**

Componente de PresentaciÃ³n:

```typescript
function UserProfilePresenter({ user }: { user: { name: string; email: string } }) {
	return (
		<h1>
			{user.name} ({user.email})
		</h1>
	);
}
```

Componente Contenedor:

```typescript
function UserProfileContainer({ userId }: { userId: number }) {
	const [user, setUser] = React.useState<{ name: string; email: string } | null>(null);

	React.useEffect(() => {
		fetch(`https://api.example.com/users/${userId}`)
			.then((res) => res.json())
			.then((data) => setUser(data));
	}, [userId]);

	if (!user) return <p>Cargando...</p>;
	return <UserProfilePresenter user={user} />;
}
```

Ahora, UserProfilePresenter solo maneja la UI, mientras que UserProfileContainer se encarga de la lÃ³gica.

---

### **Render Props â€“ Compartiendo LÃ³gica de Forma DinÃ¡mica ğŸ”„**

**ğŸ”¥ CuÃ¡ndo usarlo**
â€¢ Cuando quieres compartir lÃ³gica entre componentes sin usar HOCs.
â€¢ Cuando necesitas dar control al componente padre sobre lo que se renderiza.

**âŒ Antes (CÃ³digo Duplicado en Componentes Diferentes ğŸ¤¯)**

```typescript
function MouseTracker() {
	const [position, setPosition] = React.useState({ x: 0, y: 0 });

	React.useEffect(() => {
		const handleMouseMove = (event: MouseEvent) => {
			setPosition({ x: event.clientX, y: event.clientY });
		};
		window.addEventListener("mousemove", handleMouseMove);
		return () => window.removeEventListener("mousemove", handleMouseMove);
	}, []);

	return (
		<p>
			PosiciÃ³n del Mouse: {position.x}, {position.y}
		</p>
	);
}
```

AquÃ­, la lÃ³gica de rastreo del mouse estÃ¡ acoplada al componente.

**âœ… DespuÃ©s (Aplicando Render Props ğŸ’¡)**

```typescript
function MouseTracker({ render }: { render: (pos: { x: number; y: number }) => JSX.Element }) {
	const [position, setPosition] = React.useState({ x: 0, y: 0 });

	React.useEffect(() => {
		const handleMouseMove = (event: MouseEvent) => {
			setPosition({ x: event.clientX, y: event.clientY });
		};
		window.addEventListener("mousemove", handleMouseMove);
		return () => window.removeEventListener("mousemove", handleMouseMove);
	}, []);

	return render(position);
}

// Uso
function App() {
	return (
		<MouseTracker
			render={(position) => (
				<h1>
					El mouse estÃ¡ en {position.x}, {position.y}
				</h1>
			)}
		/>
	);
}
```

Ahora, MouseTracker no decide cÃ³mo renderizar los datos, sino que le da el control al componente padre.

---

### **Hooks Personalizados â€“ Encapsulando LÃ³gica Reutilizable ğŸª**

Los Custom Hooks son una forma moderna de React para reutilizar lÃ³gica de estado sin necesidad de HOCs o Render Props.

**ğŸ”¥ CuÃ¡ndo usarlo**
â€¢ Cuando un mismo useState y useEffect se repiten en mÃºltiples componentes.
â€¢ Para separar la lÃ³gica de negocio de la UI.

**âŒ Antes (Misma LÃ³gica en MÃºltiples Componentes ğŸ¤¦â€â™‚ï¸)**

```typescript
function UserList() {
	const [users, setUsers] = React.useState([]);

	React.useEffect(() => {
		fetch("https://api.example.com/users")
			.then((res) => res.json())
			.then((data) => setUsers(data));
	}, []);

	return (
		<ul>
			{users.map((user) => (
				<li key={user.id}>{user.name}</li>
			))}
		</ul>
	);
}
```

Si tienes otro componente que tambiÃ©n necesita usuarios, repetirÃ¡s la misma lÃ³gica.

**âœ… DespuÃ©s (Con Custom Hook ğŸ˜)**

```typescript
function useFetch<T>(url: string): T | null {
	const [data, setData] = React.useState<T | null>(null);

	React.useEffect(() => {
		fetch(url)
			.then((res) => res.json())
			.then((data) => setData(data));
	}, [url]);

	return data;
}

// Uso en diferentes componentes
function UserList() {
	const users = useFetch<{ id: number; name: string }[]>("https://api.example.com/users");
	if (!users) return <p>Cargando...</p>;
	return (
		<ul>
			{users.map((user) => (
				<li key={user.id}>{user.name}</li>
			))}
		</ul>
	);
}

function ProductList() {
	const products = useFetch<{ id: number; name: string }[]>("https://api.example.com/products");
	if (!products) return <p>Cargando...</p>;
	return (
		<ul>
			{products.map((product) => (
				<li key={product.id}>{product.name}</li>
			))}
		</ul>
	);
}
```

Ahora, useFetch encapsula la lÃ³gica de llamada a la API y se puede reutilizar en cualquier componente.

---

### **ConclusiÃ³n**

Estos patrones de diseÃ±o te ayudarÃ¡n a escribir cÃ³digo mÃ¡s limpio, reutilizable y escalable en React. ğŸš€

- **Container/Presenter** â†’ Separa lÃ³gica de presentaciÃ³n.
- **Render Props** â†’ Permite compartir lÃ³gica entre componentes.
- **Custom Hooks** â†’ Encapsula lÃ³gica reutilizable de estado.
